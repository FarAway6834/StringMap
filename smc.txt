{"my_concept_include.h": ["ascii", "#pragma once\n#ifndef _MY_CONCEPT_INCLUDE_H\n# define _MY_CONCEPT_INCLUDE_H\n\n//it have been err since today(1.13), actually, I started today.\n//it was created because of fucking error.\n//why is it err?????\n#include <concepts>\n\n#endif"], "stmc.h": ["ascii", "#pragma once\n#ifndef _STMC_H\n# define _STMC_H\n\n#include \"stmc_compresser_interface.h\"\n\nTP(autolike B, CompresserInterfaced T, typename M = strmap<B>)\nstruct CompressedStrmap {\n    /**\n     * # `CompressedStrmap` 4 using var 2 use.\n     * \n     * ## Functions (=Method... well too sucks methods (becauses...=), Actually, this is not perfect obj, and I hope it still be like union-managementing-struct)\n     * \n     * ### `constructor`) `CompressedStrmap(can be dynamic \\[compressed file | uncompressed stm file\\])`\n     * \n     * ### `__enter__`) `__enter__()` or `__enter__(size_that_will_encrease_when_decompress)`\n     * \n     * ### `__exit__`) make it compress to end (not deconstruct, it isn't delete the file \\[WARNING\\])\n     * \n     * ## field\n     * \n     * ### `var.ptr4compressed_v` : compressed ver\n     * \n     * ### `var.ptr4compressed_v` : uncompressed stm file type ver\n     * \n     * ### WARN : not type safe.\n     */\n\n    public:\n        union \n        {\n            autolike ptr4compressed_v;\n            M* ptr4decompressed_v;\n        };\n\n        final inline CompressedStrmap(autolike core) {\n            this->ptr4compressed_v = core;\n        }\n\n        final inline CompressedStrmap(M* strmap) {\n            this->ptr4decompressed_v = strmap;\n        }\n\n        final inline void __enter__(void) {\n            T.decompress_smartly(this->ptr4compressed_v);\n        }\n\n        final inline void __enter__(autolike size) {\n            T.decompress(this->ptr4compressed_v, size);\n        }\n\n        final inline void __exit__(void) {\n            T.compress(this->ptr4compressed_v);\n        }\n};\n\n#endif"], "stmc_compresser_interface.h": ["ascii", "#pragma once\n#ifndef _STMC_COMPRESSER_INTERFACE_H\n# define _STMC_COMPRESSER_INTERFACE_H\n\n#include \"my_concept_include.h\"\n#include \"strm.h\"\n\nTP(typename I, typename T)\nusing is_subcls = typename std::enable_if<std::is_base_of<I, T>::value>::type\n\nTP(autolike B, typename T = strmap<B>)\nstruct CompresserInterface\n{\n    public:\n\n        /**\n         * \n         * # CompresserInterface\n         * \n         * get compressing format info, or work compress/decompress inplace.\n         * \n         * ## \\[f\\] `ptr-typ4idx CompresserInterface.calculate_decompressed_file_size(autolike compressed-file-ptr)`\n         * \n         *  get size when decompress\n         * \n         * ## \\[inline-replace\\] `void CompresserInterface.decompress_file(ptr target, autolike decompressed_file_size)`\n         * \n         *  decompress by getting size and target ptr.\n         * \n         * ## \\[inline-replace\\] `void CompresserInterface.compress_file(ptr target)`\n         * \n         *  compress\n         *  \n         *  actually, it's too easy, It just needs to links, didn't requires other work.\n         * \n         * ## \\[inline-replace\\] `void CompresserInterface.decompress_smartly(ptr target)`\n         * \n         *  1. get `CompresserInterface.calculate_decompressed_file_size` 2 get size\n         *  2. use `CompresserInterface.decompress_file` 2 decompress\n         */\n\n        virtual static inline autolike calculate_decompressed_file_size(autolike) = 0;\n        virtual static inline void decompress_file(T*, autolike) = 0;\n        virtual static inline void compress_file(T*) = 0;\n        final static inline void decompress_smartly(T* file) {\n            decompress_file(file, calculate_decompressed_file_size(file));\n        }\n};\n\nTP(typename T)\nusing isCompresserInterface = is_subcls<CompresserInterface<autolike, strmap<autolike>>, T>;\n\nTP(typename T)\nconcept CompresserInterfaced = isCompresserInterface<T>::value;\n\n#endif"], "strm.h": ["ascii", "#pragma once\n#ifndef _STRM_H\n# define _STRM_H\n\n#include \"typs.h\"\n\nnamespace strmc {\n\n    TP(autolike B)\n    struct bidxt //B-filted idxTyp\n    {\n        autolike v : B;\n    };\n\n    typedef struct {\n        strt v;\n    } not_basically_nullptred_strt;\n\n    typedef struct {\n        strt v = nullptr;\n    } basically_nullptred_strt;\n\n    TP(autolike B, bool basically_nullptred = false, typename T = bidxt<B>, typename MAPT = std::conditional<basically_nullptred, basically_nullptred_strt, not_basically_nullptred_strt>)\n    struct strmap {\n        /**\n         * # file format `strmap`\n         * \n         * ## call : strmap(filename)\n         * \n         *  return hash-mapping ptr\n         * \n         * ## idx : strmap[filename]\n         * \n         *  hashmap idx access\n         * \n         * ## how2work?\n         * \n         *  - `indexof_dataseg frame[hash(filename)]`\n         *  - `txt-file-seg dataseg`\n         * \n         * it work as hash-map\n         */\n        public:\n            MAPT frame[1<<B]; //MAP\n            char detaseg[8<<sizeof(strt)]; //DATAS\n            \n            /**\n             * # `strt& obj(strt filename)` it returns index of where file is placeses\n             * \n             * ## fixing link\n             * \n             * it can change where obj[filename] is pointing.\n             * \n             * ### index nullptr\n             * \n             *  = undefined\n             * \n             * ## why `final` used\n             * \n             * it should be work as struct, but objective.\n             */\n            final inline strt& operator()(strt filename) { //getlink;\n                return &this->frame[this->strhash(filename)].v;\n            }\n\n            /**\n             * # `strt& obj[strt filename]` use obj as an hashmap, by using obj(filename) to get index.\n             * \n             * ## undefined value\n             * \n             *  = if null returns.\n             * \n             * ## why `final` used\n             * \n             * it should be work as struct, but objective.\n             */\n            final inline strt& operator[](strt filename) {\n                register strt idx = *this(filename);\n                return idx==nullptr?null:&dataseg[idx]; //oh shit I don't know what I should do to.\n            }   \n\n        protected:\n            virtual inline T strhash(strt) = 0;\n    };\n};\n\nusing strmc::strmap; //strmap<B>\n\n#endif"], "typs.h": ["ascii", "#pragma once\n#ifndef _TYPS_H\n# define _TYPS_H\n\n#include <type_traits>\n#define TP(...) template <__VA_ARGS__>\ntypedef void* autolike;\ntypedef char* strt;\n\n#endif"]}